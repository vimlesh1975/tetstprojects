"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NCSServerConnection = exports.DEFAULT_COMMAND_TIMEOUT = void 0;
const mosSocketClient_1 = require("../connection/mosSocketClient");
const helper_1 = require("@mos-connection/helper");
const events_1 = require("events");
exports.DEFAULT_COMMAND_TIMEOUT = 5000;
/** Handles connections to a NCS (server) */
class NCSServerConnection extends events_1.EventEmitter {
    constructor(id, host, mosID, timeout, heartbeatsInterval, debug) {
        super();
        this._disposed = false;
        this._clients = {};
        this._emittedConnected = false;
        this._id = id;
        this._host = host;
        this._timeout = timeout || exports.DEFAULT_COMMAND_TIMEOUT;
        this._heartBeatsInterval = Math.max(heartbeatsInterval || 0, this._timeout);
        this._mosID = mosID;
        this._connected = false;
        this._debug = debug ?? false;
    }
    /** Create a MOS client, which talks to  */
    createClient(clientID, port, clientDescription, useHeartbeats) {
        const client = new mosSocketClient_1.MosSocketClient(this._host, port, clientDescription, this._timeout, this._debug);
        this.debugTrace('registerOutgoingConnection', clientID);
        this._clients[clientID] = {
            useHeartbeats: useHeartbeats,
            heartbeatConnected: false,
            client: client,
            clientDescription: clientDescription,
        };
        client.on('rawMessage', (type, message) => {
            this.emit('rawMessage', type, message);
        });
        client.on('warning', (str) => {
            this.emit('warning', 'MosSocketClient: ' + str);
        });
        client.on('error', (str) => {
            this.emit('error', 'MosSocketClient: ' + str);
        });
    }
    /** */
    removeClient(clientID) {
        this._clients[clientID].client.dispose();
        delete this._clients[clientID];
    }
    connect() {
        for (const i in this._clients) {
            // Connect client
            this.emit('info', `Connect client ${i} on ${this._clients[i].clientDescription} on host ${this._host} (${this._clients[i].client.port})`);
            this.debugTrace(`Connect client ${i} on ${this._clients[i].clientDescription} on host ${this._host} (${this._clients[i].client.port})`);
            this._clients[i].client.connect();
        }
        this._connected = true;
        // Send heartbeat and check connection
        this._sendHeartBeats();
        // Emit to _callbackOnConnectionChange
        // if (this._callbackOnConnectionChange) this._callbackOnConnectionChange()
    }
    async executeCommand(message) {
        // Fill with clients
        let clients;
        // Set mosID and ncsID
        message.mosID = this._mosID;
        message.ncsID = this._id;
        // Example: Port based on message type
        if (message.port === 'lower') {
            clients = this.lowerPortClients;
        }
        else if (message.port === 'upper') {
            clients = this.upperPortClients;
        }
        else if (message.port === 'query') {
            clients = this.queryPortClients;
        }
        else {
            throw Error(`No "${message.port}" ports found`);
        }
        return new Promise((resolve, reject) => {
            if (clients && clients.length) {
                clients[0].queueCommand(message, (err, data) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(data);
                    }
                });
            }
            else {
                reject('executeCommand: No clients found for ' + message.port);
            }
        });
    }
    setDebug(debug) {
        this._debug = debug;
        Object.keys(this._clients).forEach((clientID) => {
            const cd = this._clients[clientID];
            if (cd) {
                cd.client.setDebug(debug);
            }
        });
    }
    get connected() {
        if (!this._connected)
            return false;
        let connected = true;
        Object.keys(this._clients).forEach((key) => {
            const client = this._clients[key];
            if (client.useHeartbeats && !client.heartbeatConnected) {
                connected = false;
            }
        });
        return connected;
    }
    _getClients(clientDescription) {
        const clients = [];
        for (const i in this._clients) {
            if (this._clients[i].clientDescription === clientDescription) {
                clients.push(this._clients[i].client);
            }
        }
        return clients;
    }
    /** */
    get lowerPortClients() {
        return this._getClients('lower');
    }
    /** */
    get upperPortClients() {
        return this._getClients('upper');
    }
    /** */
    get queryPortClients() {
        return this._getClients('query');
    }
    get host() {
        return this._host;
    }
    get id() {
        return this._id;
    }
    handOverQueue(otherConnection) {
        const cmds = {};
        // this._clients.forEach((client, id) => {
        // 	// cmds[id] = client.client.handOverQueue()
        // })
        this.debugTrace(this.id + ' ' + this.host + ' handOverQueue');
        for (const id in this._clients) {
            cmds[id] = this._clients[id].client.handOverQueue();
        }
        otherConnection.receiveQueue(cmds);
    }
    receiveQueue(queue) {
        // @todo: keep order
        // @todo: prevent callback-promise horror...
        for (const clientId of Object.keys(queue)) {
            for (const msg of queue[clientId].messages) {
                this.executeCommand(msg.msg).then((data) => {
                    const cb = queue[clientId].callbacks[msg.msg.messageID];
                    if (cb) {
                        cb(null, data);
                    }
                }, (err) => {
                    const cb = queue[clientId].callbacks[msg.msg.messageID];
                    if (cb) {
                        cb(null, err);
                    }
                });
            }
        }
    }
    async dispose() {
        this._disposed = true;
        for (const key in this._clients) {
            this.removeClient(key);
        }
        if (this._heartBeatsTimer) {
            global.clearTimeout(this._heartBeatsTimer);
            delete this._heartBeatsTimer;
        }
        this._connected = false;
        this.emit('connectionChanged');
    }
    _sendHeartBeats() {
        if (this._heartBeatsTimer) {
            clearTimeout(this._heartBeatsTimer);
            delete this._heartBeatsTimer;
        }
        if (this._disposed)
            return;
        const triggerNextHeartBeat = () => {
            if (this._disposed)
                return;
            this._heartBeatsTimer = global.setTimeout(() => {
                if (!this._disposed)
                    this._sendHeartBeats();
            }, this._heartBeatsInterval);
        };
        Promise.all(Object.keys(this._clients).map(async (key) => {
            const client = this._clients[key];
            if (client.useHeartbeats) {
                const heartbeat = new helper_1.MosModel.HeartBeat(this._clients[key].clientDescription, undefined, true);
                try {
                    await this.executeCommand(heartbeat);
                    client.heartbeatConnected = true;
                }
                catch (e) {
                    // probably a timeout
                    client.heartbeatConnected = false;
                    this.emit('error', `Heartbeat error on ${this._clients[key].clientDescription}: ${e}`);
                    this.debugTrace(`Heartbeat on ${this._clients[key].clientDescription}: ${e}`);
                }
            }
        }))
            .catch((e) => {
            triggerNextHeartBeat();
            this.emit('error', e);
        })
            .then(() => {
            const connected = this.connected;
            if (connected !== this._emittedConnected) {
                this._emittedConnected = connected;
                this.emit('connectionChanged');
            }
            triggerNextHeartBeat();
        })
            .catch((e) => {
            this.emit('error', e);
        });
    }
    debugTrace(...strs) {
        // eslint-disable-next-line no-console
        if (this._debug)
            console.log(...strs);
    }
}
exports.NCSServerConnection = NCSServerConnection;
//# sourceMappingURL=NCSServerConnection.js.map