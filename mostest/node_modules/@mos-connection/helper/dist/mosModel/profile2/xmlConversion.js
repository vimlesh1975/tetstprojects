"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XMLObjectPaths = exports.XMLMosExternalMetaData = exports.XMLMosItem = exports.XMLMosItems = exports.XMLROStory = exports.XMLROStoryBase = exports.XMLROStories = exports.XMLRunningOrder = exports.XMLRunningOrderBase = exports.XMLMosROAck = void 0;
const XMLBuilder = require("xmlbuilder");
const model_1 = require("@mos-connection/model");
const lib_1 = require("../lib");
const ROAck_1 = require("./ROAck");
const xmlConversion_1 = require("../profile1/xmlConversion");
const Utils_1 = require("../../utils/Utils");
/* eslint-disable @typescript-eslint/no-namespace */
var XMLMosROAck;
(function (XMLMosROAck) {
    function fromXML(xml, strict) {
        const mosTypes = (0, model_1.getMosTypes)(strict);
        const roAck = new ROAck_1.ROAck({
            ID: mosTypes.mosString128.create(xml.roID),
            Status: mosTypes.mosString128.create(xml.roStatus),
            Stories: [],
        }, strict);
        let xmlStoryIDs = xml.storyID;
        let xmlItemIDs = xml.itemID;
        let xmlObjIDs = xml.objID;
        let xmlStatuses = xml.status;
        if (!Array.isArray(xmlStoryIDs))
            xmlStoryIDs = [xmlStoryIDs];
        if (!Array.isArray(xmlItemIDs))
            xmlItemIDs = [xmlItemIDs];
        if (!Array.isArray(xmlObjIDs))
            xmlObjIDs = [xmlObjIDs];
        if (!Array.isArray(xmlStatuses))
            xmlStatuses = [xmlStatuses];
        roAck.Stories = [];
        const iMax = Math.max(xmlStoryIDs.length, xmlItemIDs.length, xmlObjIDs.length, xmlStatuses.length);
        let story = null;
        let item = null;
        let object = null;
        for (let i = 0; i < iMax; i++) {
            if (xmlStoryIDs[i]) {
                story = {
                    ID: mosTypes.mosString128.create(xmlStoryIDs[i]),
                    Items: [],
                };
                roAck.Stories.push(story);
            }
            if (xmlItemIDs[i]) {
                item = {
                    ID: mosTypes.mosString128.create(xmlStoryIDs[i]),
                    Channel: mosTypes.mosString128.create(''),
                    Objects: [],
                };
                if (story)
                    story.Items.push(item);
            }
            if (xmlObjIDs[i] && xmlStatuses[i]) {
                object = {
                    Status: xmlStatuses[i],
                    ID: xmlObjIDs[i],
                };
                if (item)
                    item.Objects.push(object);
            }
        }
        return roAck;
    }
    XMLMosROAck.fromXML = fromXML;
})(XMLMosROAck = exports.XMLMosROAck || (exports.XMLMosROAck = {}));
var XMLRunningOrderBase;
(function (XMLRunningOrderBase) {
    function fromXML(xml, strict) {
        const mosTypes = (0, model_1.getMosTypes)(strict);
        const ro = {
            ID: mosTypes.mosString128.create(xml.roID),
            Slug: mosTypes.mosString128.create(xml.roSlug),
        };
        if ((0, lib_1.has)(xml, 'roEdStart') && !(0, lib_1.isEmpty)(xml.roEdStart))
            ro.EditorialStart = mosTypes.mosTime.create(xml.roEdStart);
        if ((0, lib_1.has)(xml, 'roEdDur') && !(0, lib_1.isEmpty)(xml.roEdDur))
            ro.EditorialDuration = mosTypes.mosDuration.create(xml.roEdDur);
        if ((0, lib_1.has)(xml, 'roChannel') && !(0, lib_1.isEmpty)(xml.roChannel))
            ro.DefaultChannel = mosTypes.mosString128.create(xml.roChannel);
        if ((0, lib_1.has)(xml, 'roTrigger') && !(0, lib_1.isEmpty)(xml.roTrigger))
            ro.Trigger = mosTypes.mosString128.create(xml.roTrigger);
        if ((0, lib_1.has)(xml, 'macroIn') && !(0, lib_1.isEmpty)(xml.macroIn))
            ro.MacroIn = mosTypes.mosString128.create(xml.macroIn);
        if ((0, lib_1.has)(xml, 'macroOut') && !(0, lib_1.isEmpty)(xml.macroOut))
            ro.MacroOut = mosTypes.mosString128.create(xml.macroOut);
        if ((0, lib_1.has)(xml, 'mosExternalMetadata') && !(0, lib_1.isEmpty)(xml.mosExternalMetadata)) {
            // TODO: Handle an array of mosExternalMetadata
            const meta = {
                MosSchema: xml.mosExternalMetadata.mosSchema,
                MosPayload: xml.mosExternalMetadata.mosPayload,
            };
            if ((0, lib_1.has)(xml.mosExternalMetadata, 'mosScope'))
                meta.MosScope = xml.mosExternalMetadata.mosScope;
            ro.MosExternalMetaData = [meta];
        }
        return ro;
    }
    XMLRunningOrderBase.fromXML = fromXML;
    function toXML(xmlRo, ro, strict) {
        (0, Utils_1.addTextElementInternal)(xmlRo, 'roID', ro.ID, undefined, strict);
        (0, Utils_1.addTextElementInternal)(xmlRo, 'roSlug', ro.Slug, undefined, strict);
        if (ro.DefaultChannel)
            (0, Utils_1.addTextElementInternal)(xmlRo, 'roChannel', ro.DefaultChannel, undefined, strict);
        if (ro.EditorialStart)
            (0, Utils_1.addTextElementInternal)(xmlRo, 'roEdStart', ro.EditorialStart, undefined, strict);
        if (ro.EditorialDuration)
            (0, Utils_1.addTextElementInternal)(xmlRo, 'roEdDur', ro.EditorialDuration, undefined, strict);
        if (ro.Trigger)
            (0, Utils_1.addTextElementInternal)(xmlRo, 'roTrigger', ro.Trigger, undefined, strict);
        if (ro.MacroIn)
            (0, Utils_1.addTextElementInternal)(xmlRo, 'macroIn', ro.MacroIn, undefined, strict);
        if (ro.MacroOut)
            (0, Utils_1.addTextElementInternal)(xmlRo, 'macroOut', ro.MacroOut, undefined, strict);
        XMLMosExternalMetaData.toXML(xmlRo, ro.MosExternalMetaData);
    }
    XMLRunningOrderBase.toXML = toXML;
})(XMLRunningOrderBase = exports.XMLRunningOrderBase || (exports.XMLRunningOrderBase = {}));
var XMLRunningOrder;
(function (XMLRunningOrder) {
    function fromXML(xml, strict) {
        const stories = XMLROStories.fromXML(xml.story, strict);
        const ro = {
            ...XMLRunningOrderBase.fromXML(xml, strict),
            Stories: stories,
        };
        return ro;
    }
    XMLRunningOrder.fromXML = fromXML;
})(XMLRunningOrder = exports.XMLRunningOrder || (exports.XMLRunningOrder = {}));
var XMLROStories;
(function (XMLROStories) {
    function fromXML(xml, strict) {
        if (!xml)
            return [];
        let xmlStories = xml;
        if (!Array.isArray(xmlStories))
            xmlStories = [xmlStories];
        return xmlStories.map((xmlStory) => {
            return XMLROStory.fromXML(xmlStory, strict);
        });
    }
    XMLROStories.fromXML = fromXML;
})(XMLROStories = exports.XMLROStories || (exports.XMLROStories = {}));
var XMLROStoryBase;
(function (XMLROStoryBase) {
    function toXML(xmlStory, story, strict) {
        (0, Utils_1.addTextElementInternal)(xmlStory, 'storyID', story.ID, undefined, strict);
        if (story.Slug)
            (0, Utils_1.addTextElementInternal)(xmlStory, 'storySlug', story.Slug, undefined, strict);
        if (story.Number)
            (0, Utils_1.addTextElementInternal)(xmlStory, 'storyNum', story.Number, undefined, strict);
        XMLMosExternalMetaData.toXML(xmlStory, story.MosExternalMetaData);
    }
    XMLROStoryBase.toXML = toXML;
})(XMLROStoryBase = exports.XMLROStoryBase || (exports.XMLROStoryBase = {}));
var XMLROStory;
(function (XMLROStory) {
    function fromXML(xml, strict) {
        const mosTypes = (0, model_1.getMosTypes)(strict);
        const story = {
            ID: mosTypes.mosString128.create(xml.storyID),
            Slug: mosTypes.mosString128.create(xml.storySlug),
            Items: [],
            // TODO: Add & test Number, ObjectID, MOSID, mosAbstract, Paths
            // Channel, EditorialStart, EditorialDuration, UserTimingDuration, Trigger, MacroIn, MacroOut, MosExternalMetaData
            // MosExternalMetaData: MOSExternalMetaData.fromXML(xml.mosExternalMetadata)
        };
        if ((0, lib_1.has)(xml, 'item'))
            story.Items = story.Items.concat(XMLMosItems.fromXML(xml.item, strict));
        if ((0, lib_1.has)(xml, 'storyBody') && xml.storyBody) {
            // Note: the <storyBody> is sent in roStorySend
            if ((0, lib_1.has)(xml.storyBody, 'storyItem')) {
                story.Items = story.Items.concat(XMLMosItems.fromXML(xml.storyBody.storyItem, strict));
            }
        }
        if ((0, lib_1.has)(xml, 'mosExternalMetadata'))
            story.MosExternalMetaData = XMLMosExternalMetaData.fromXML(xml.mosExternalMetadata);
        if ((0, lib_1.has)(xml, 'storyNum') && !(0, lib_1.isEmpty)(xml.storyNum))
            story.Number = mosTypes.mosString128.create(xml.storyNum || '');
        return story;
    }
    XMLROStory.fromXML = fromXML;
    function toXML(xmlRoot, story, strict) {
        const xmlStory = (0, Utils_1.addTextElementInternal)(xmlRoot, 'story', undefined, undefined, strict);
        XMLROStoryBase.toXML(xmlStory, story, strict);
        story.Items.forEach((item) => {
            XMLMosItem.toXML(xmlStory, item, strict);
        });
    }
    XMLROStory.toXML = toXML;
})(XMLROStory = exports.XMLROStory || (exports.XMLROStory = {}));
var XMLMosItems;
(function (XMLMosItems) {
    function fromXML(xml, strict) {
        if (!xml)
            return [];
        let xmlItems = xml;
        if (!Array.isArray(xmlItems))
            xmlItems = [xmlItems];
        return xmlItems.map((xmlItem) => {
            return XMLMosItem.fromXML(xmlItem, strict);
        });
    }
    XMLMosItems.fromXML = fromXML;
})(XMLMosItems = exports.XMLMosItems || (exports.XMLMosItems = {}));
var XMLMosItem;
(function (XMLMosItem) {
    function fromXML(xml, strict) {
        const mosTypes = (0, model_1.getMosTypes)(strict);
        const item = {
            ID: mosTypes.mosString128.create(xml.itemID),
            ObjectID: mosTypes.mosString128.create(xml.objID),
            MOSID: xml.mosID,
            // TODO: mosAbstract?: string,
            // TODO: Channel?: MosString128,
            // TODO: MacroIn?: MosString128,
            // TODO: MacroOut?: MosString128,
        };
        if ((0, lib_1.has)(xml, 'itemSlug') && !(0, lib_1.isEmpty)(xml.itemSlug))
            item.Slug = mosTypes.mosString128.create(xml.itemSlug);
        if ((0, lib_1.has)(xml, 'objPaths'))
            item.Paths = XMLObjectPaths.fromXML(xml.objPaths);
        if ((0, lib_1.has)(xml, 'itemEdStart'))
            item.EditorialStart = (0, lib_1.numberOrUndefined)(xml.itemEdStart);
        if ((0, lib_1.has)(xml, 'itemEdDur'))
            item.EditorialDuration = (0, lib_1.numberOrUndefined)(xml.itemEdDur);
        if ((0, lib_1.has)(xml, 'itemUserTimingDur'))
            item.UserTimingDuration = (0, lib_1.numberOrUndefined)(xml.itemUserTimingDur);
        if ((0, lib_1.has)(xml, 'itemTrigger'))
            item.Trigger = xml.itemTrigger;
        if ((0, lib_1.has)(xml, 'mosExternalMetadata'))
            item.MosExternalMetaData = XMLMosExternalMetaData.fromXML(xml.mosExternalMetadata);
        if ((0, lib_1.has)(xml, 'mosAbstract'))
            item.mosAbstract = xml.mosAbstract + '';
        if ((0, lib_1.has)(xml, 'objSlug'))
            item.ObjectSlug = (0, model_1.getMosTypes)(false).mosString128.create(xml.objSlug); // temporary fix for long slugs
        if ((0, lib_1.has)(xml, 'itemChannel'))
            item.Channel = mosTypes.mosString128.create(xml.itemChannel);
        if ((0, lib_1.has)(xml, 'objDur'))
            item.Duration = (0, lib_1.numberOrUndefined)(xml.objDur);
        if ((0, lib_1.has)(xml, 'objTB'))
            item.TimeBase = (0, lib_1.numberOrUndefined)(xml.objTB);
        if ((0, lib_1.has)(xml, 'macroIn'))
            item.MacroIn = mosTypes.mosString128.create(xml.macroIn);
        if ((0, lib_1.has)(xml, 'macroOut'))
            item.MacroOut = mosTypes.mosString128.create(xml.macroOut);
        if ((0, lib_1.has)(xml, 'mosObj')) {
            // Note: the <mosObj> is sent in roStorySend
            item.MosObjects = xmlConversion_1.XMLMosObjects.fromXML(xml.mosObj, strict);
        }
        return item;
    }
    XMLMosItem.fromXML = fromXML;
    function toXML(root, item, strict) {
        const xmlItem = (0, Utils_1.addTextElementInternal)(root, 'item', undefined, undefined, strict);
        (0, Utils_1.addTextElementInternal)(xmlItem, 'itemID', item.ID, undefined, strict);
        (0, Utils_1.addTextElementInternal)(xmlItem, 'objID', item.ObjectID, undefined, strict);
        (0, Utils_1.addTextElementInternal)(xmlItem, 'mosID', item.MOSID, undefined, strict);
        if (item.Slug)
            (0, Utils_1.addTextElementInternal)(xmlItem, 'itemSlug', item.Slug, undefined, strict);
        if (item.ObjectSlug)
            (0, Utils_1.addTextElementInternal)(xmlItem, 'objSlug', item.ObjectSlug, undefined, strict);
        if (item.Duration)
            (0, Utils_1.addTextElementInternal)(xmlItem, 'objDur', item.Duration, undefined, strict);
        if (item.TimeBase)
            (0, Utils_1.addTextElementInternal)(xmlItem, 'objTB', item.TimeBase, undefined, strict);
        if (item.mosAbstract)
            (0, Utils_1.addTextElementInternal)(xmlItem, 'mosAbstract', item.mosAbstract, undefined, strict);
        if (item.Channel)
            (0, Utils_1.addTextElementInternal)(xmlItem, 'itemChannel', item.Channel, undefined, strict);
        if (item.EditorialStart !== undefined)
            (0, Utils_1.addTextElementInternal)(xmlItem, 'itemEdStart', item.EditorialStart, undefined, strict);
        if (item.EditorialDuration !== undefined)
            (0, Utils_1.addTextElementInternal)(xmlItem, 'itemEdDur', item.EditorialDuration, undefined, strict);
        if (item.UserTimingDuration !== undefined)
            (0, Utils_1.addTextElementInternal)(xmlItem, 'itemUserTimingDur', item.UserTimingDuration, undefined, strict);
        if (item.Trigger)
            (0, Utils_1.addTextElementInternal)(xmlItem, 'itemTrigger', item.Trigger, undefined, strict);
        if (item.MacroIn)
            (0, Utils_1.addTextElementInternal)(xmlItem, 'macroIn', item.MacroIn, undefined, strict);
        if (item.MacroOut)
            (0, Utils_1.addTextElementInternal)(xmlItem, 'macroOut', item.MacroOut, undefined, strict);
        XMLMosExternalMetaData.toXML(xmlItem, item.MosExternalMetaData);
        XMLObjectPaths.toXML(xmlItem, item.Paths, strict);
    }
    XMLMosItem.toXML = toXML;
})(XMLMosItem = exports.XMLMosItem || (exports.XMLMosItem = {}));
var XMLMosExternalMetaData;
(function (XMLMosExternalMetaData) {
    function fromXML(xml) {
        if (!xml)
            return [];
        let xmlMetadata = xml;
        if (!Array.isArray(xml))
            xmlMetadata = [xmlMetadata];
        return xmlMetadata.map((xmlmd) => {
            const md = {
                MosScope: (0, lib_1.has)(xmlmd, 'mosScope') ? xmlmd.mosScope : null,
                MosSchema: xmlmd.mosSchema + '',
                MosPayload: _fixPayload(xmlmd.mosPayload),
            };
            return md;
        });
    }
    XMLMosExternalMetaData.fromXML = fromXML;
    function toXML(xml, metadatas) {
        if (metadatas) {
            metadatas.forEach((metadata) => {
                const xmlMetadata = XMLBuilder.create({
                    mosExternalMetadata: {
                        mosSchema: metadata.MosSchema,
                        mosPayload: metadata.MosPayload,
                        mosScope: metadata.MosScope,
                    },
                });
                xml.importDocument(xmlMetadata);
            });
        }
    }
    XMLMosExternalMetaData.toXML = toXML;
})(XMLMosExternalMetaData = exports.XMLMosExternalMetaData || (exports.XMLMosExternalMetaData = {}));
function _handlePayloadProperties(prop) {
    // prop is string, can be a mis-typing of number - if it contains numbers and comma
    // strings with numbers and , grouped will trigger
    if (prop && typeof prop === 'string' && prop.match(/\d+,\d+/)) {
        // here is the fix for replacing and casting
        const commaCast = prop.replace(/,/, '.');
        const floatCast = parseFloat(commaCast);
        // ensure that the float hasn't changed value or content by checking it in reverse before returning the altered one
        if (floatCast.toString() === commaCast) {
            return floatCast;
        }
    }
    // return the original content if we failed to identify and mutate the content
    return prop;
}
function _fixPayload(obj) {
    if (typeof obj === 'object') {
        for (const key in obj) {
            const o = obj[key];
            if (typeof o === 'object') {
                if ((0, lib_1.isEmpty)(o)) {
                    obj[key] = '';
                }
                else {
                    _fixPayload(o);
                }
            }
            else {
                // do property-check on certain props (like MediaTime)
                obj[key] = _handlePayloadProperties(o);
            }
        }
    }
    else {
        // do property-check on certain props (like MediaTime)
        obj = _handlePayloadProperties(obj);
    }
    return obj;
}
var XMLObjectPaths;
(function (XMLObjectPaths) {
    function fromXML(xml) {
        if (!xml)
            return [];
        const getType = (xml) => {
            let type = null;
            if ((0, lib_1.has)(xml, 'objPath') || xml.$name === 'objPath') {
                type = model_1.IMOSObjectPathType.PATH;
            }
            else if ((0, lib_1.has)(xml, 'objProxyPath') || xml.$name === 'objProxyPath') {
                type = model_1.IMOSObjectPathType.PROXY_PATH;
            }
            else if ((0, lib_1.has)(xml, 'objMetadataPath') || xml.$name === 'objMetadataPath') {
                type = model_1.IMOSObjectPathType.METADATA_PATH;
            }
            return type;
        };
        const getDescription = (xml) => {
            return xml.techDescription || (xml.attributes ? xml.attributes.techDescription : '');
        };
        const getTarget = (xml) => {
            return xml.text || xml.$t;
        };
        const getMosObjectPath = (element, key) => {
            let type = getType(element);
            if (!type && key) {
                type = getType({ $name: key });
            }
            const target = getTarget(element);
            const description = getDescription(element);
            if (type && target) {
                return {
                    Type: type,
                    Description: description,
                    Target: target,
                };
            }
            return undefined;
        };
        const xmlToArray = (obj) => {
            let paths = [];
            if ((0, lib_1.has)(obj, 'techDescription')) {
                const mosObj = getMosObjectPath(obj);
                if (mosObj) {
                    paths.push(mosObj);
                }
            }
            else {
                Object.keys(obj).forEach((key) => {
                    const element = obj[key];
                    if (Array.isArray(element)) {
                        paths = paths.concat(xmlToArray(element));
                    }
                    else {
                        const mosObj = getMosObjectPath(element, key);
                        if (mosObj) {
                            paths.push(mosObj);
                        }
                    }
                });
            }
            return paths;
        };
        const xmlPaths = xmlToArray(xml);
        return xmlPaths;
    }
    XMLObjectPaths.fromXML = fromXML;
    function toXML(xmlItem, paths, strict) {
        if (paths) {
            const xmlObjPaths = (0, Utils_1.addTextElementInternal)(xmlItem, 'objPaths', undefined, undefined, strict);
            paths.forEach((path) => {
                if (path.Type === model_1.IMOSObjectPathType.PATH) {
                    (0, Utils_1.addTextElementInternal)(xmlObjPaths, 'objPath', path.Target, {
                        techDescription: path.Description,
                    }, strict);
                }
                else if (path.Type === model_1.IMOSObjectPathType.PROXY_PATH) {
                    (0, Utils_1.addTextElementInternal)(xmlObjPaths, 'objProxyPath', path.Target, {
                        techDescription: path.Description,
                    }, strict);
                }
                else if (path.Type === model_1.IMOSObjectPathType.METADATA_PATH) {
                    (0, Utils_1.addTextElementInternal)(xmlObjPaths, 'objMetadataPath', path.Target, {
                        techDescription: path.Description,
                    }, strict);
                }
            });
        }
    }
    XMLObjectPaths.toXML = toXML;
})(XMLObjectPaths = exports.XMLObjectPaths || (exports.XMLObjectPaths = {}));
//# sourceMappingURL=xmlConversion.js.map