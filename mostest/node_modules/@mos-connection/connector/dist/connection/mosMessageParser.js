"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosMessageParser = void 0;
const events_1 = require("events");
const helper_1 = require("@mos-connection/helper");
class MosMessageParser extends events_1.EventEmitter {
    constructor(description) {
        super();
        this.description = description;
        this.dataChunks = '';
        this.debug = false;
    }
    parseMessage(messageString) {
        this.debugTrace(`Socket got data (${this.description}): "${messageString}"`);
        this.dataChunks += messageString;
        // parse as many messages as possible from the data
        while (this.dataChunks.length > 0) {
            // whitespace before a mos message is junk
            this.dataChunks = this.dataChunks.trimStart();
            const lengthBefore = this.dataChunks.length;
            this._tryParseData();
            const lengthAfter = this.dataChunks.length;
            if (lengthAfter === lengthBefore) {
                // Nothing was plucked, so abort
                break;
            }
        }
    }
    _tryParseData() {
        const startMatch = '<mos>'; // <mos>
        const endMatch = '</mos>'; // </mos>
        let messageString;
        const startIndex = this.dataChunks.indexOf(startMatch);
        if (startIndex === -1) {
            // No start tag, so looks like we have jibberish
            this.dataChunks = '';
        }
        else {
            if (startIndex > 0) {
                const junkStr = this.dataChunks.slice(0, startIndex);
                this.debugTrace(`${this.description} Discarding message fragment: "${junkStr}"`);
                // trim off anything before <mos>, as we'll never be able to parse that anyway.
                this.dataChunks = this.dataChunks.slice(startIndex);
            }
            const endIndex = this.dataChunks.indexOf(endMatch);
            if (endIndex >= 0) {
                // We have an end too, so pull out the message
                const endIndex2 = endIndex + endMatch.length;
                messageString = this.dataChunks.slice(0, endIndex2);
                this.dataChunks = this.dataChunks.slice(endIndex2);
                // parse our xml
            }
        }
        let parsedData = null;
        try {
            if (messageString) {
                parsedData = (0, helper_1.xml2js)(messageString); // , { compact: true, trim: true, nativeType: true })
            }
        }
        catch (err) {
            console.log('dataChunks-------------\n', this.dataChunks);
            console.log('messageString---------\n', messageString);
            // this.emit('error', e)
            throw err;
        }
        if (parsedData) {
            this.emit('message', parsedData, messageString);
        }
    }
    debugTrace(str) {
        if (this.debug) {
            // Supress console spam:
            if (!`${str}`.match(/<heartbeat>/)) {
                // eslint-disable-next-line no-console
                console.log(str);
            }
        }
    }
}
exports.MosMessageParser = MosMessageParser;
//# sourceMappingURL=mosMessageParser.js.map