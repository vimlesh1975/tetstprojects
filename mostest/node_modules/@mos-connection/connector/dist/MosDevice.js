"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosDevice = void 0;
const net_1 = require("net");
const model_1 = require("@mos-connection/model");
const helper_1 = require("@mos-connection/helper");
const lib_1 = require("./lib");
class MosDevice {
    constructor(idPrimary, idSecondary, connectionConfig, primaryConnection, secondaryConnection, offSpecFailover, strict) {
        this._debug = false;
        this.supportedProfiles = {
            deviceType: 'MOS',
            profile0: false,
            profile1: false,
            profile2: false,
            profile3: false,
            profile4: false,
            profile5: false,
            profile6: false,
            profile7: false,
        }; // Use same names as IProfiles?
        this._disposed = false;
        this._primaryConnection = null;
        this._secondaryConnection = null;
        this._currentConnection = null;
        // this._id = this.mosTypes.mosString128.create(connectionConfig.mosID).toString()
        this._idPrimary = idPrimary;
        this._idSecondary = idSecondary;
        this.socket = new net_1.Socket();
        this.strict = strict;
        this.mosTypes = (0, model_1.getMosTypes)(this.strict);
        // Add params to this in MosConnection/MosDevice
        this.manufacturer = this.mosTypes.mosString128.create('RadioVision, Ltd.');
        this.model = this.mosTypes.mosString128.create('TCS6000');
        this.hwRev = this.mosTypes.mosString128.create('0.1'); // empty string returnes <hwRev/>
        this.swRev = this.mosTypes.mosString128.create('0.1');
        this.DOM = this.mosTypes.mosTime.create(undefined);
        this.SN = this.mosTypes.mosString128.create('927748927');
        this.ID = this.mosTypes.mosString128.create(connectionConfig ? connectionConfig.mosID : '');
        this.time = this.mosTypes.mosTime.create(undefined);
        this.opTime = this.mosTypes.mosTime.create(undefined);
        this.mosRev = this.mosTypes.mosString128.create('2.8.5');
        if (connectionConfig) {
            if (connectionConfig.profiles['0'])
                this.supportedProfiles.profile0 = true;
            if (connectionConfig.profiles['1'])
                this.supportedProfiles.profile1 = true;
            if (connectionConfig.profiles['2'])
                this.supportedProfiles.profile2 = true;
            if (connectionConfig.profiles['3'])
                this.supportedProfiles.profile3 = true;
            if (connectionConfig.profiles['4'])
                this.supportedProfiles.profile4 = true;
            if (connectionConfig.profiles['5'])
                this.supportedProfiles.profile5 = true;
            if (connectionConfig.profiles['6'])
                this.supportedProfiles.profile6 = true;
            if (connectionConfig.profiles['7'])
                this.supportedProfiles.profile7 = true;
            if (connectionConfig.isNCS)
                this.supportedProfiles.deviceType = 'NCS';
            if (connectionConfig.debug)
                this._debug = connectionConfig.debug;
        }
        if (primaryConnection) {
            this._primaryConnection = primaryConnection;
            this._primaryConnection.on('connectionChanged', () => {
                this._emitConnectionChange();
                if (offSpecFailover &&
                    this._currentConnection !== this._primaryConnection &&
                    this._primaryConnection?.connected) {
                    this.switchConnections(); // and hope no current message goes lost
                }
            });
        }
        if (secondaryConnection) {
            this._secondaryConnection = secondaryConnection;
            this._secondaryConnection.on('connectionChanged', () => this._emitConnectionChange());
        }
        this._currentConnection = this._primaryConnection || this._secondaryConnection || null;
        if (this.strict) {
            const orgStack = new Error();
            setTimeout(() => {
                if (this._disposed)
                    return;
                try {
                    this._checkProfileValidness(orgStack);
                }
                catch (e) {
                    // eslint-disable-next-line no-console
                    console.error(e);
                }
            }, 100);
        }
    }
    /** True if MOS-device has connection to server (can send messages) */
    get hasConnection() {
        return !!this._currentConnection;
    }
    /** Primary ID (probably the NCS-ID) */
    get idPrimary() {
        return this._idPrimary;
    }
    /** Secondary / Buddy ID (probably the MOS-ID) */
    get idSecondary() {
        return this._idSecondary;
    }
    /** Host name (IP-address) of the primary server */
    get primaryHost() {
        return this._primaryConnection ? this._primaryConnection.host : null;
    }
    /** Name (ID) of the primary server */
    get primaryId() {
        return this._primaryConnection ? this._primaryConnection.id : null;
    }
    /** Host name (IP-address) of the secondary (buddy) server */
    get secondaryHost() {
        return this._secondaryConnection ? this._secondaryConnection.host : null;
    }
    /** Name (ID) of the secondary (buddy) server */
    get secondaryId() {
        return this._secondaryConnection ? this._secondaryConnection.id : null;
    }
    connect() {
        if (this._primaryConnection)
            this._primaryConnection.connect();
        if (this._secondaryConnection)
            this._secondaryConnection.connect();
    }
    async dispose() {
        this._currentConnection = null;
        const ps = [];
        if (this._primaryConnection)
            ps.push(this._primaryConnection.dispose());
        if (this._secondaryConnection)
            ps.push(this._secondaryConnection.dispose());
        await Promise.all(ps);
    }
    async routeData(data, port) {
        if (data && (0, lib_1.has)(data, 'mos'))
            data = data['mos'];
        // Suppress console spam:
        if (!(0, lib_1.has)(data, 'heartbeat')) {
            this.debugTrace('parsedData', data);
            // this.debugTrace('keys', Object.keys(data))
        }
        // Route and format data:
        // Profile 0:
        if (data.heartbeat) {
            // send immediate reply on the same port:
            return new helper_1.MosModel.HeartBeat(port, undefined, this.strict);
        }
        else if (data.reqMachInfo && typeof this._callbackOnRequestMachineInfo === 'function') {
            if (port === 'query')
                throw new Error('message "reqMachInfo" is invalid on query port');
            const m = await this._callbackOnRequestMachineInfo();
            return new helper_1.MosModel.ListMachineInfo(m, port, this.strict);
            // Profile 1:
        }
        else if (data.mosReqObj && typeof this._callbackOnRequestMOSOBject === 'function') {
            const mosObj = await this._callbackOnRequestMOSOBject(data.mosReqObj.objID);
            if (!mosObj)
                return null;
            return new helper_1.MosModel.MosObj(mosObj, this.strict);
        }
        else if (data.mosReqAll && typeof this._callbackOnRequestAllMOSObjects === 'function') {
            const pause = data.mosReqAll.pause || 0;
            const mosObjects = await this._callbackOnRequestAllMOSObjects();
            setImmediate(() => {
                // spec: Pause, when greater than zero, indicates the number of seconds to pause
                // between individual mosObj messages.
                // Pause of zero indicates that all objects will be sent using the mosListAll message..
                // https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosReqAll
                if (pause > 0) {
                    if (mosObjects.length) {
                        // const firstObject = mosObjects.shift() as IMOSObject
                        // const resp = new MosObj(firstObject)
                        // resolve(resp)
                        const sendNextObject = () => {
                            if (this._disposed)
                                return;
                            const nextObject = mosObjects.shift();
                            if (nextObject) {
                                this.sendMOSObject(nextObject)
                                    .then(() => {
                                    setTimeout(sendNextObject, pause * 1000);
                                })
                                    .catch((e) => {
                                    console.error('Error in async mosObj response to mosReqAll', e);
                                });
                            }
                        };
                        setTimeout(sendNextObject, pause * 1000);
                    }
                }
                else {
                    this._sendAllMOSObjects(mosObjects).catch((e) => {
                        console.error('Error in async mosListAll response to mosReqAll', e);
                    });
                }
            });
            // What this should contain isn't well defined in the protocol
            return new helper_1.MosModel.MOSAck({
                ID: this.mosTypes.mosString128.create(0),
                Revision: 0,
                Description: this.mosTypes.mosString128.create(''),
                Status: model_1.IMOSAckStatus.ACK,
            }, this.strict);
            // Profile 2:
        }
        else if (data.roCreate && typeof this._callbackOnCreateRunningOrder === 'function') {
            const ro = helper_1.MosModel.XMLRunningOrder.fromXML(data.roCreate, this.strict);
            const resp = await this._callbackOnCreateRunningOrder(ro);
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.roReplace && typeof this._callbackOnReplaceRunningOrder === 'function') {
            const ro = helper_1.MosModel.XMLRunningOrder.fromXML(data.roReplace, this.strict);
            const resp = await this._callbackOnReplaceRunningOrder(ro);
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.roDelete && typeof this._callbackOnDeleteRunningOrder === 'function') {
            // TODO: Change runningOrderId to RunningOrderID in interface?
            const resp = await this._callbackOnDeleteRunningOrder(data.roDelete.roID);
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.roReq && typeof this._callbackOnRequestRunningOrder === 'function') {
            const ro = await this._callbackOnRequestRunningOrder(data.roReq.roID);
            if (ro) {
                return new helper_1.MosModel.ROList(ro, this.strict);
            }
            else {
                // RO not found
                return new helper_1.MosModel.ROAck({
                    ID: data.roReq.roID,
                    Status: this.mosTypes.mosString128.create(model_1.IMOSAckStatus.NACK),
                    Stories: [],
                }, this.strict);
            }
        }
        else if (data.roMetadataReplace && typeof this._callbackOnMetadataReplace === 'function') {
            const ro = helper_1.MosModel.XMLRunningOrderBase.fromXML(data.roMetadataReplace, this.strict);
            const resp = await this._callbackOnMetadataReplace(ro);
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.roElementStat &&
            data.roElementStat.element === 'RO' &&
            typeof this._callbackOnRunningOrderStatus === 'function') {
            const status = {
                ID: this.mosTypes.mosString128.create(data.roElementStat.roID),
                Status: data.roElementStat.status,
                Time: this.mosTypes.mosTime.create(data.roElementStat.time),
            };
            const resp = await this._callbackOnRunningOrderStatus(status);
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.roElementStat &&
            data.roElementStat.element === 'STORY' &&
            typeof this._callbackOnStoryStatus === 'function') {
            const status = {
                RunningOrderId: this.mosTypes.mosString128.create(data.roElementStat.roID),
                ID: this.mosTypes.mosString128.create(data.roElementStat.storyID),
                Status: data.roElementStat.status,
                Time: this.mosTypes.mosTime.create(data.roElementStat.time),
            };
            const resp = await this._callbackOnStoryStatus(status);
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.roElementStat &&
            data.roElementStat.element === 'ITEM' &&
            typeof this._callbackOnItemStatus === 'function') {
            const status = {
                RunningOrderId: this.mosTypes.mosString128.create(data.roElementStat.roID),
                StoryId: this.mosTypes.mosString128.create(data.roElementStat.storyID),
                ID: this.mosTypes.mosString128.create(data.roElementStat.itemID),
                Status: data.roElementStat.status,
                Time: this.mosTypes.mosTime.create(data.roElementStat.time),
            };
            if ((0, lib_1.has)(data.roElementStat, 'objID'))
                status.ObjectId = this.mosTypes.mosString128.create(data.roElementStat.objID);
            if ((0, lib_1.has)(data.roElementStat, 'itemChannel'))
                status.Channel = this.mosTypes.mosString128.create(data.roElementStat.itemChannel);
            const resp = await this._callbackOnItemStatus(status);
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.roReadyToAir && typeof this._callbackOnReadyToAir === 'function') {
            const resp = await this._callbackOnReadyToAir({
                ID: this.mosTypes.mosString128.create(data.roReadyToAir.roID),
                Status: data.roReadyToAir.roAir,
            });
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.roElementAction &&
            data.roElementAction.operation === 'INSERT' &&
            (data.roElementAction.element_source || {}).story &&
            typeof this._callbackOnROInsertStories === 'function') {
            const action = {
                RunningOrderID: this.mosTypes.mosString128.create(data.roElementAction.roID),
                StoryID: this.mosTypes.mosString128.create((data.roElementAction.element_target || {}).storyID),
            };
            const stories = helper_1.MosModel.XMLROStories.fromXML([data.roElementAction.element_source.story], this.strict);
            const resp = await this._callbackOnROInsertStories(action, stories);
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.roElementAction &&
            data.roElementAction.operation === 'INSERT' &&
            (data.roElementAction.element_source || {}).item &&
            typeof this._callbackOnROInsertItems === 'function') {
            const action = {
                RunningOrderID: this.mosTypes.mosString128.create(data.roElementAction.roID),
                StoryID: this.mosTypes.mosString128.create((data.roElementAction.element_target || {}).storyID),
                ItemID: this.mosTypes.mosString128.create((data.roElementAction.element_target || {}).itemID),
            };
            const items = helper_1.MosModel.XMLMosItems.fromXML(data.roElementAction.element_source.item, this.strict);
            const resp = await this._callbackOnROInsertItems(action, items);
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.roElementAction &&
            data.roElementAction.operation === 'REPLACE' &&
            (data.roElementAction.element_source || {}).story &&
            typeof this._callbackOnROReplaceStories === 'function') {
            const action = {
                RunningOrderID: this.mosTypes.mosString128.create(data.roElementAction.roID),
                StoryID: this.mosTypes.mosString128.create((data.roElementAction.element_target || {}).storyID),
            };
            const stories = helper_1.MosModel.XMLROStories.fromXML([data.roElementAction.element_source.story], this.strict);
            const resp = await this._callbackOnROReplaceStories(action, stories);
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.roElementAction &&
            data.roElementAction.operation === 'REPLACE' &&
            (data.roElementAction.element_source || {}).item &&
            typeof this._callbackOnROReplaceItems === 'function') {
            const action = {
                RunningOrderID: this.mosTypes.mosString128.create(data.roElementAction.roID),
                StoryID: this.mosTypes.mosString128.create((data.roElementAction.element_target || {}).storyID),
                ItemID: this.mosTypes.mosString128.create((data.roElementAction.element_target || {}).itemID),
            };
            const items = helper_1.MosModel.XMLMosItems.fromXML(data.roElementAction.element_source.item, this.strict);
            const resp = await this._callbackOnROReplaceItems(action, items);
            resp.Stories = []; // dont return these (?)
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.roElementAction &&
            data.roElementAction.operation === 'MOVE' &&
            (data.roElementAction.element_source || {}).storyID &&
            typeof this._callbackOnROMoveStories === 'function') {
            const action = {
                RunningOrderID: this.mosTypes.mosString128.create(data.roElementAction.roID),
                StoryID: this.mosTypes.mosString128.create((data.roElementAction.element_target || {}).storyID),
            };
            const storyIDs = helper_1.MosModel.XMLMosIDs.fromXML(data.roElementAction.element_source.storyID, this.strict);
            const resp = await this._callbackOnROMoveStories(action, storyIDs);
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.roElementAction &&
            data.roElementAction.operation === 'MOVE' &&
            (data.roElementAction.element_source || {}).itemID &&
            typeof this._callbackOnROMoveItems === 'function') {
            const action = {
                RunningOrderID: this.mosTypes.mosString128.create(data.roElementAction.roID),
                StoryID: this.mosTypes.mosString128.create((data.roElementAction.element_target || {}).storyID),
                ItemID: this.mosTypes.mosString128.create((data.roElementAction.element_target || {}).itemID),
            };
            const itemIDs = helper_1.MosModel.XMLMosIDs.fromXML(data.roElementAction.element_source.itemID, this.strict);
            const resp = await this._callbackOnROMoveItems(action, itemIDs);
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.roElementAction &&
            data.roElementAction.operation === 'DELETE' &&
            data.roElementAction.element_source.storyID &&
            typeof this._callbackOnRODeleteStories === 'function') {
            const stories = helper_1.MosModel.XMLMosIDs.fromXML(data.roElementAction.element_source.storyID, this.strict);
            const resp = await this._callbackOnRODeleteStories({
                RunningOrderID: this.mosTypes.mosString128.create(data.roElementAction.roID),
            }, stories);
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.roElementAction &&
            data.roElementAction.operation === 'DELETE' &&
            data.roElementAction.element_source.itemID &&
            typeof this._callbackOnRODeleteItems === 'function') {
            const action = {
                RunningOrderID: this.mosTypes.mosString128.create(data.roElementAction.roID),
                StoryID: this.mosTypes.mosString128.create((data.roElementAction.element_target || {}).storyID),
            };
            const items = helper_1.MosModel.XMLMosIDs.fromXML(data.roElementAction.element_source.itemID, this.strict);
            const resp = await this._callbackOnRODeleteItems(action, items);
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.roElementAction &&
            data.roElementAction.operation === 'SWAP' &&
            data.roElementAction.element_source.storyID &&
            data.roElementAction.element_source.storyID.length === 2 &&
            typeof this._callbackOnROSwapStories === 'function') {
            const stories = helper_1.MosModel.XMLMosIDs.fromXML(data.roElementAction.element_source.storyID, this.strict);
            const resp = await this._callbackOnROSwapStories({
                RunningOrderID: this.mosTypes.mosString128.create(data.roElementAction.roID),
            }, stories[0], stories[1]);
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.roElementAction &&
            data.roElementAction.operation === 'SWAP' &&
            data.roElementAction.element_source.itemID &&
            data.roElementAction.element_source.itemID.length === 2 &&
            typeof this._callbackOnROSwapItems === 'function') {
            const items = helper_1.MosModel.XMLMosIDs.fromXML(data.roElementAction.element_source.itemID, this.strict);
            const resp = await this._callbackOnROSwapItems({
                RunningOrderID: this.mosTypes.mosString128.create(data.roElementAction.roID),
                StoryID: this.mosTypes.mosString128.create((data.roElementAction.element_target || {}).storyID),
            }, items[0], items[1]);
            return new helper_1.MosModel.ROAck(resp, this.strict);
            // Profile 3
        }
        else if (data.mosItemReplace && typeof this._callbackOnItemReplace === 'function') {
            const resp = await this._callbackOnItemReplace(data.mosItemReplace.ID, data.mosItemReplace.itemID, helper_1.MosModel.XMLMosItem.fromXML(data.mosItemReplace.item, this.strict));
            return new helper_1.MosModel.ROAck(resp, this.strict);
        }
        else if (data.mosObjCreate && typeof this._callbackOnObjectCreate === 'function') {
            const resp = await this._callbackOnObjectCreate(helper_1.MosModel.XMLMosObject.fromXML(data.mosObjCreate, this.strict));
            const ack = new helper_1.MosModel.MOSAck(resp, this.strict);
            return ack;
        }
        else if (data.mosReqObjAction &&
            data.mosReqObjAction.operation === 'NEW' &&
            typeof this._callbackOnRequestObjectActionNew === 'function') {
            const resp = await this._callbackOnRequestObjectActionNew(helper_1.MosModel.XMLMosObject.fromXML(data.mosReqObjAction, this.strict));
            return new helper_1.MosModel.MOSAck(resp, this.strict);
        }
        else if (data.mosReqObjAction &&
            data.mosReqObjAction.operation === 'UPDATE' &&
            typeof this._callbackOnRequestObjectActionUpdate === 'function') {
            const resp = await this._callbackOnRequestObjectActionUpdate(data.mosReqObjAction.objID, helper_1.MosModel.XMLMosObject.fromXML(data.mosReqObjAction, this.strict));
            return new helper_1.MosModel.MOSAck(resp, this.strict);
        }
        else if (data.mosReqObjAction &&
            data.mosReqObjAction.operation === 'DELETE' &&
            typeof this._callbackOnRequestObjectActionDelete === 'function') {
            const resp = await this._callbackOnRequestObjectActionDelete(data.mosReqObjAction.objID);
            return new helper_1.MosModel.MOSAck(resp, this.strict);
        }
        else if (data.mosReqObjList && typeof this._callbackOnRequestObjectList === 'function') {
            const resp = await this._callbackOnRequestObjectList(helper_1.MosModel.XMLMosRequestObjectList.fromXML(data.mosReqObjList));
            return new helper_1.MosModel.MosObjList(resp, this.strict);
        }
        else if (data.mosReqSearchableSchema && typeof this._callbackOnRequestSearchableSchema === 'function') {
            const resp = await this._callbackOnRequestSearchableSchema(data.mosReqSearchableSchema.username);
            return new helper_1.MosModel.MosListSearchableSchema(resp, this.strict);
            // Profile 4
        }
        else if (data.roReqAll && typeof this._callbackOnRequestAllRunningOrders === 'function') {
            const list = await this._callbackOnRequestAllRunningOrders();
            const roListAll = new helper_1.MosModel.ROListAll(this.strict);
            roListAll.ROs = list;
            return roListAll;
        }
        else if (data.roStorySend && typeof this._callbackOnRunningOrderStory === 'function') {
            const story = helper_1.MosModel.XMLROFullStory.fromXML(data.roStorySend, this.strict);
            const resp = await this._callbackOnRunningOrderStory(story);
            return new helper_1.MosModel.ROAck(resp, this.strict);
            // TODO: Use MosMessage instead of string
            // TODO: Use reject if function dont exists? Put Nack in ondata
        }
        else {
            this.debugTrace('Unsupported function');
            this.debugTrace(data);
            const keys = Object.keys(data).filter((key) => ['ncsID', 'mosID', 'messageID'].indexOf(key) === -1);
            return new helper_1.MosModel.MOSAck({
                ID: this.mosTypes.mosString128.create(0),
                Revision: 0,
                Description: this.mosTypes.mosString128.create(`Unsupported function: "${keys.join(', ')}"`),
                Status: model_1.IMOSAckStatus.NACK,
            }, this.strict);
        }
    }
    // ============================================================================================================
    // ==========================   Profile 0   ===================================================================
    // ============================================================================================================
    async requestMachineInfo() {
        const message = new helper_1.MosModel.ReqMachInfo(this.strict);
        const data = await this.executeCommand(message);
        const listMachInfo = data.mos.listMachInfo;
        const list = {
            manufacturer: this.mosTypes.mosString128.create(listMachInfo.manufacturer),
            model: this.mosTypes.mosString128.create(listMachInfo.model),
            hwRev: this.mosTypes.mosString128.create(listMachInfo.hwRev),
            swRev: this.mosTypes.mosString128.create(listMachInfo.swRev),
            DOM: this.mosTypes.mosString128.create(listMachInfo.DOM),
            SN: this.mosTypes.mosString128.create(listMachInfo.SN),
            ID: this.mosTypes.mosString128.create(listMachInfo.ID),
            time: this.mosTypes.mosTime.create(listMachInfo.time),
            opTime: this.mosTypes.mosTime.create(listMachInfo.opTime),
            mosRev: this.mosTypes.mosString128.create(listMachInfo.mosRev),
            supportedProfiles: {
                deviceType: listMachInfo.supportedProfiles.deviceType,
            },
            defaultActiveX: listMachInfo.defaultActiveX,
            mosExternalMetaData: listMachInfo.mosExternalMetaData,
        };
        if (Array.isArray(listMachInfo.supportedProfiles.mosProfile)) {
            for (const mosProfile of listMachInfo.supportedProfiles.mosProfile) {
                // @ts-expect-error hack
                list.supportedProfiles[`profile${mosProfile.attributes.number}`] = mosProfile.text === 'YES';
            }
        }
        return list;
    }
    onRequestMachineInfo(cb) {
        this.checkProfile('onRequestMachineInfo', 'profile1');
        this._callbackOnRequestMachineInfo = cb;
    }
    onConnectionChange(cb) {
        this.checkProfile('onConnectionChange', 'profile1');
        this._callbackOnConnectionChange = cb;
    }
    getConnectionStatus() {
        // TODO: Implement this
        return {
            PrimaryConnected: this._primaryConnection ? this._primaryConnection.connected : false,
            PrimaryStatus: '',
            SecondaryConnected: this._secondaryConnection ? this._secondaryConnection.connected : false,
            SecondaryStatus: '',
        };
    }
    // Deprecated methods:
    /** @deprecated getMachineInfo is deprecated, use requestMachineInfo instead */
    async getMachineInfo() {
        return this.requestMachineInfo();
    }
    /** @deprecated onGetMachineInfo is deprecated, use onRequestMachineInfo instead */
    onGetMachineInfo(cb) {
        return this.onRequestMachineInfo(cb);
    }
    // ============================================================================================================
    // ==========================   Profile 1   ===================================================================
    // ============================================================================================================
    async sendMOSObject(obj) {
        const message = new helper_1.MosModel.MosObj(obj, this.strict);
        const reply = await this.executeCommand(message);
        const ack = helper_1.MosModel.XMLMosAck.fromXML(reply.mos.mosAck, this.strict);
        return ack;
    }
    onRequestMOSObject(cb) {
        this.checkProfile('onRequestMOSObject', 'profile1');
        this._callbackOnRequestMOSOBject = cb;
    }
    async sendRequestMOSObject(objID) {
        const message = new helper_1.MosModel.ReqMosObj(objID, this.strict);
        const reply = await this.executeCommand(message);
        if (reply.mos.roAck) {
            throw new Error(helper_1.MosModel.XMLMosROAck.fromXML(reply.mos.roAck, this.strict).toString());
        }
        else if (reply.mos.mosObj) {
            const obj = helper_1.MosModel.XMLMosObject.fromXML(reply.mos.mosObj, this.strict);
            return obj;
        }
        else {
            throw new Error(`Unknown response: ${(0, lib_1.safeStringify)(reply).slice(0, 200)}`);
        }
    }
    onRequestAllMOSObjects(cb) {
        this.checkProfile('onRequestAllMOSObjects', 'profile1');
        this._callbackOnRequestAllMOSObjects = cb;
    }
    async sendRequestAllMOSObjects() {
        const message = new helper_1.MosModel.ReqMosObjAll(undefined, this.strict);
        const reply = await this.executeCommand(message);
        if (reply.mos.roAck) {
            throw new Error(helper_1.MosModel.XMLMosROAck.fromXML(reply.mos.roAck, this.strict).toString());
        }
        else if (reply.mos.mosListAll) {
            const objs = helper_1.MosModel.XMLMosObjects.fromXML(reply.mos.mosListAll.mosObj, this.strict);
            return objs;
        }
        else {
            throw new Error(`Unknown response: ${(0, lib_1.safeStringify)(reply).slice(0, 200)}`);
        }
    }
    /**
     * https://mosprotocol.com/wp-content/MOS-Protocol-Documents/MOS-Protocol-2.8.4-Current.htm#mosListAll
     */
    async _sendAllMOSObjects(objs) {
        const message = new helper_1.MosModel.MosListAll(objs, this.strict);
        const reply = await this.executeCommand(message);
        if (reply.mos) {
            const ack = helper_1.MosModel.XMLMosAck.fromXML(reply.mos.mosAck, this.strict);
            return ack;
        }
        else {
            throw new Error(`Unknown response: ${(0, lib_1.safeStringify)(reply).slice(0, 200)}`);
        }
    }
    /**
     * @deprecated getMOSObject is deprecated, use sendRequestMOSObject instead
     */
    async getMOSObject(objId) {
        return this.sendRequestMOSObject(objId);
    }
    /** @deprecated getAllMOSObjects is deprecated, use sendRequestAllMOSObjects instead */
    async getAllMOSObjects() {
        return this.sendRequestAllMOSObjects();
    }
    // ============================================================================================================
    // ==========================   Profile 2   ===================================================================
    // ============================================================================================================
    onCreateRunningOrder(cb) {
        this.checkProfile('onCreateRunningOrder', 'profile2');
        this._callbackOnCreateRunningOrder = cb;
    }
    async sendCreateRunningOrder(ro) {
        const message = new helper_1.MosModel.ROCreate(ro, this.strict);
        const data = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(data.mos.roAck, this.strict);
    }
    onReplaceRunningOrder(cb) {
        this.checkProfile('onReplaceRunningOrder', 'profile2');
        this._callbackOnReplaceRunningOrder = cb;
    }
    async sendReplaceRunningOrder(ro) {
        const message = new helper_1.MosModel.ROReplace(ro, this.strict);
        const data = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(data.mos.roAck, this.strict);
    }
    onDeleteRunningOrder(cb) {
        this.checkProfile('onDeleteRunningOrder', 'profile2');
        this._callbackOnDeleteRunningOrder = cb;
    }
    async sendDeleteRunningOrder(runningOrderId) {
        const message = new helper_1.MosModel.RODelete(runningOrderId, this.strict);
        const data = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(data.mos.roAck, this.strict);
    }
    onRequestRunningOrder(cb) {
        this.checkProfile('onRequestRunningOrder', 'profile2');
        this._callbackOnRequestRunningOrder = cb;
    }
    async sendRequestRunningOrder(runningOrderId) {
        const message = new helper_1.MosModel.ROReq(runningOrderId, this.strict);
        const reply = await this.executeCommand(message);
        if (reply.mos.roList) {
            const ro = helper_1.MosModel.XMLRunningOrder.fromXML(reply.mos.roList, this.strict);
            return ro;
        }
        else
            throw new Error(`Unknown response: ${(0, lib_1.safeStringify)(reply).slice(0, 200)}`);
    }
    /**
     * @deprecated getRunningOrder is deprecated, use sendRequestRunningOrder instead
     */
    async getRunningOrder(runningOrderId) {
        return this.sendRequestRunningOrder(runningOrderId);
    }
    onMetadataReplace(cb) {
        this.checkProfile('onMetadataReplace', 'profile2');
        this._callbackOnMetadataReplace = cb;
    }
    async sendMetadataReplace(metadata) {
        const message = new helper_1.MosModel.ROMetadataReplace(metadata, this.strict);
        const data = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(data.mos.roAck, this.strict);
    }
    onRunningOrderStatus(cb) {
        this.checkProfile('onRunningOrderStatus', 'profile2');
        this._callbackOnRunningOrderStatus = cb;
    }
    onStoryStatus(cb) {
        this.checkProfile('onStoryStatus', 'profile2');
        this._callbackOnStoryStatus = cb;
    }
    onItemStatus(cb) {
        this.checkProfile('onItemStatus', 'profile2');
        this._callbackOnItemStatus = cb;
    }
    /** @deprecated setRunningOrderStatus is deprecated, use sendRunningOrderStatus instead */
    async setRunningOrderStatus(status) {
        return this.sendRunningOrderStatus(status);
    }
    /** @deprecated setStoryStatus is deprecated, use sendStoryStatus instead */
    async setStoryStatus(status) {
        return this.sendStoryStatus(status);
    }
    /** @deprecated setItemStatus is deprecated, use sendItemStatus instead */
    async setItemStatus(status) {
        return this.sendItemStatus(status);
    }
    async sendRunningOrderStatus(status) {
        const message = new helper_1.MosModel.ROElementStat({
            type: helper_1.MosModel.ROElementStatType.RO,
            roId: this.mosTypes.mosString128.create(status.ID),
            status: status.Status,
        }, this.strict);
        const reply = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(reply.mos.roAck, this.strict);
    }
    async sendStoryStatus(status) {
        const message = new helper_1.MosModel.ROElementStat({
            type: helper_1.MosModel.ROElementStatType.STORY,
            roId: this.mosTypes.mosString128.create(status.RunningOrderId),
            storyId: this.mosTypes.mosString128.create(status.ID),
            status: status.Status,
        }, this.strict);
        const reply = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(reply.mos.roAck, this.strict);
    }
    async sendItemStatus(status) {
        const message = new helper_1.MosModel.ROElementStat({
            type: helper_1.MosModel.ROElementStatType.ITEM,
            roId: this.mosTypes.mosString128.create(status.RunningOrderId),
            storyId: this.mosTypes.mosString128.create(status.StoryId),
            itemId: this.mosTypes.mosString128.create(status.ID),
            objId: this.mosTypes.mosString128.create(status.ObjectId),
            itemChannel: this.mosTypes.mosString128.create(status.Channel),
            status: status.Status,
        }, this.strict);
        const reply = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(reply.mos.roAck, this.strict);
    }
    onReadyToAir(cb) {
        this.checkProfile('onReadyToAir', 'profile2');
        this._callbackOnReadyToAir = cb;
    }
    async sendReadyToAir(Action) {
        const message = new helper_1.MosModel.ROReadyToAir({
            roId: Action.ID,
            roAir: Action.Status,
        }, this.strict);
        const reply = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(reply.mos.roAck, this.strict);
    }
    onROInsertStories(cb) {
        this.checkProfile('onROInsertStories', 'profile2');
        this._callbackOnROInsertStories = cb;
    }
    async sendROInsertStories(Action, Stories) {
        const message = new helper_1.MosModel.ROInsertStories(Action, Stories, this.strict);
        const data = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(data.mos.roAck, this.strict);
    }
    onROInsertItems(cb) {
        this.checkProfile('onROInsertItems', 'profile2');
        this._callbackOnROInsertItems = cb;
    }
    async sendROInsertItems(Action, Items) {
        const message = new helper_1.MosModel.ROInsertItems(Action, Items, this.strict);
        const data = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(data.mos.roAck, this.strict);
    }
    onROReplaceStories(cb) {
        this.checkProfile('onROReplaceStories', 'profile2');
        this._callbackOnROReplaceStories = cb;
    }
    async sendROReplaceStories(Action, Stories) {
        const message = new helper_1.MosModel.ROReplaceStories(Action, Stories, this.strict);
        const data = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(data.mos.roAck, this.strict);
    }
    onROReplaceItems(cb) {
        this.checkProfile('onROReplaceItems', 'profile2');
        this._callbackOnROReplaceItems = cb;
    }
    async sendROReplaceItems(Action, Items) {
        const message = new helper_1.MosModel.ROReplaceItems(Action, Items, this.strict);
        const data = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(data.mos.roAck, this.strict);
    }
    onROMoveStories(cb) {
        this.checkProfile('onROMoveStories', 'profile2');
        this._callbackOnROMoveStories = cb;
    }
    async sendROMoveStories(Action, Stories) {
        const message = new helper_1.MosModel.ROMoveStories(Action, Stories, this.strict);
        const data = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(data.mos.roAck, this.strict);
    }
    onROMoveItems(cb) {
        this.checkProfile('onROMoveItems', 'profile2');
        this._callbackOnROMoveItems = cb;
    }
    async sendROMoveItems(Action, Items) {
        const message = new helper_1.MosModel.ROMoveItems(Action, Items, this.strict);
        const data = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(data.mos.roAck, this.strict);
    }
    onRODeleteStories(cb) {
        this.checkProfile('onRODeleteStories', 'profile2');
        this._callbackOnRODeleteStories = cb;
    }
    async sendRODeleteStories(Action, Stories) {
        const message = new helper_1.MosModel.RODeleteStories(Action, Stories, this.strict);
        const data = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(data.mos.roAck, this.strict);
    }
    onRODeleteItems(cb) {
        this.checkProfile('onRODeleteItems', 'profile2');
        this._callbackOnRODeleteItems = cb;
    }
    async sendRODeleteItems(Action, Items) {
        const message = new helper_1.MosModel.RODeleteItems(Action, Items, this.strict);
        const data = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(data.mos.roAck, this.strict);
    }
    onROSwapStories(cb) {
        this.checkProfile('onROSwapStories', 'profile2');
        this._callbackOnROSwapStories = cb;
    }
    async sendROSwapStories(Action, StoryID0, StoryID1) {
        const message = new helper_1.MosModel.ROSwapStories(Action, StoryID0, StoryID1, this.strict);
        const data = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(data.mos.roAck, this.strict);
    }
    onROSwapItems(cb) {
        this.checkProfile('onROSwapItems', 'profile2');
        this._callbackOnROSwapItems = cb;
    }
    async sendROSwapItems(Action, ItemID0, ItemID1) {
        const message = new helper_1.MosModel.ROSwapItems(Action, ItemID0, ItemID1, this.strict);
        const data = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(data.mos.roAck, this.strict);
    }
    // ============================================================================================================
    // ==========================   Profile 3   ===================================================================
    // ============================================================================================================
    onObjectCreate(cb) {
        this.checkProfile('', 'profile3');
        this._callbackOnObjectCreate = cb;
    }
    async sendObjectCreate(object) {
        const message = new helper_1.MosModel.MosObjCreate(object, this.strict);
        const data = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosAck.fromXML(data.mos.mosAck, this.strict);
    }
    onItemReplace(cb) {
        this.checkProfile('onItemReplace', 'profile3');
        this._callbackOnItemReplace = cb;
    }
    async sendItemReplace(options) {
        const message = new helper_1.MosModel.MosItemReplace(options, this.strict);
        const data = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(data.mos.roAck, this.strict);
    }
    onRequestSearchableSchema(cb) {
        this.checkProfile('onRequestSearchableSchema', 'profile3');
        this._callbackOnRequestSearchableSchema = cb;
    }
    async sendRequestSearchableSchema(username) {
        const message = new helper_1.MosModel.MosReqSearchableSchema({ username }, this.strict);
        const response = await this.executeCommand(message);
        return response.mos.mosListSearchableSchema;
    }
    onRequestObjectList(cb) {
        this.checkProfile('onRequestObjectList', 'profile3');
        this._callbackOnRequestObjectList = cb;
    }
    async sendRequestObjectList(reqObjList) {
        const message = new helper_1.MosModel.MosReqObjList(reqObjList, this.strict);
        const response = await this.executeCommand(message);
        const objList = response.mos.mosObjList;
        if (objList.list)
            objList.list = helper_1.MosModel.XMLMosObjects.fromXML(objList.list.mosObj, this.strict);
        return objList;
    }
    onRequestObjectActionNew(cb) {
        this.checkProfile('onRequestObjectActionNew', 'profile3');
        this._callbackOnRequestObjectActionNew = cb;
    }
    async sendRequestObjectActionNew(obj) {
        const message = new helper_1.MosModel.MosReqObjActionNew({ object: obj }, this.strict);
        const response = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosAck.fromXML(response.mos.mosAck, this.strict);
    }
    onRequestObjectActionUpdate(cb) {
        this.checkProfile('onRequestObjectActionUpdate', 'profile3');
        this._callbackOnRequestObjectActionUpdate = cb;
    }
    async sendRequestObjectActionUpdate(objId, obj) {
        const message = new helper_1.MosModel.MosReqObjActionUpdate({ object: obj, objectId: objId }, this.strict);
        const response = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosAck.fromXML(response.mos.mosAck, this.strict);
    }
    onRequestObjectActionDelete(cb) {
        this.checkProfile('onRequestObjectActionDelete', 'profile3');
        this._callbackOnRequestObjectActionDelete = cb;
    }
    async sendRequestObjectActionDelete(objId) {
        const message = new helper_1.MosModel.MosReqObjActionDelete({ objectId: objId }, this.strict);
        const response = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosAck.fromXML(response.mos.mosAck, this.strict);
    }
    // Deprecated methods:
    /** @deprecated onMosObjCreate is deprecated, use onObjectCreate instead */
    onMosObjCreate(cb) {
        return this.onObjectCreate(cb);
    }
    /** @deprecated mosObjCreate is deprecated, use sendObjectCreate instead */
    async mosObjCreate(object) {
        return this.sendObjectCreate(object);
    }
    /** @deprecated onMosItemReplace is deprecated, use onItemReplace instead */
    onMosItemReplace(cb) {
        return this.onItemReplace(cb);
    }
    /** @deprecated mosItemReplace is deprecated, use sendItemReplace instead */
    async mosItemReplace(options) {
        return this.sendItemReplace(options);
    }
    /** @deprecated onMosReqSearchableSchema is deprecated, use onRequestSearchableSchema instead */
    onMosReqSearchableSchema(cb) {
        return this.onRequestSearchableSchema(cb);
    }
    /** @deprecated mosRequestSearchableSchema is deprecated, use sendRequestSearchableSchema instead */
    async mosRequestSearchableSchema(username) {
        return this.sendRequestSearchableSchema(username);
    }
    /** @deprecated onMosReqObjectList is deprecated, use onRequestObjectList instead */
    onMosReqObjectList(cb) {
        return this.onRequestObjectList(cb);
    }
    /** @deprecated mosRequestObjectList is deprecated, use sendRequestObjectList instead */
    async mosRequestObjectList(reqObjList) {
        return this.sendRequestObjectList(reqObjList);
    }
    /** @deprecated onMosReqObjectAction is deprecated, use onRequestObjectAction*** instead */
    onMosReqObjectAction(_cb) {
        throw new Error('onMosReqObjectAction is deprecated, use onRequestObjectAction*** instead');
    }
    // ============================================================================================================
    // ==========================   Profile 4   ===================================================================
    // ============================================================================================================
    onRequestAllRunningOrders(cb) {
        this.checkProfile('onRequestAllRunningOrders', 'profile4');
        this._callbackOnRequestAllRunningOrders = cb;
    }
    async sendRequestAllRunningOrders() {
        const message = new helper_1.MosModel.ROReqAll(this.strict);
        if (this._currentConnection) {
            const reply = await this.executeCommand(message);
            if ((0, lib_1.has)(reply.mos, 'roListAll')) {
                let xmlRos = (reply.mos.roListAll || {}).ro;
                if (!Array.isArray(xmlRos))
                    xmlRos = [xmlRos];
                const ros = [];
                xmlRos.forEach((xmlRo) => {
                    if (xmlRo) {
                        ros.push(helper_1.MosModel.XMLRunningOrderBase.fromXML(xmlRo, this.strict));
                    }
                });
                return ros;
            }
            else
                throw new Error(`Unknown response: ${(0, lib_1.safeStringify)(reply).slice(0, 200)}`);
        }
        else
            throw new Error(`Unable to send message due to no current connection`);
    }
    onRunningOrderStory(cb) {
        this.checkProfile('onRunningOrderStory', 'profile4');
        this._callbackOnRunningOrderStory = cb;
    }
    async sendRunningOrderStory(story) {
        const message = new helper_1.MosModel.ROStory(story, this.strict);
        const data = await this.executeCommand(message);
        return helper_1.MosModel.XMLMosROAck.fromXML(data.mos.roAck, this.strict);
    }
    // Deprecated methods:
    /** @deprecated onROReqAll is deprecated, use onRequestAllRunningOrders instead */
    onROReqAll(cb) {
        return this.onRequestAllRunningOrders(cb);
    }
    /** @deprecated getAllRunningOrders is deprecated, use sendRequestAllRunningOrders instead */
    async getAllRunningOrders() {
        return this.sendRequestAllRunningOrders();
    }
    /** @deprecated onROStory is deprecated, use onRunningOrderStory instead */
    onROStory(cb) {
        return this.onRunningOrderStory(cb);
    }
    /** @deprecated sendROStory is deprecated, use sendRunningOrderStory instead */
    async sendROStory(story) {
        return this.sendRunningOrderStory(story);
    }
    // =============================================================================================================
    // ///////////////////////////////////// End of Profile methods \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    setDebug(debug) {
        this._debug = debug;
    }
    checkProfileValidness() {
        const orgStack = new Error();
        this._checkProfileValidness(orgStack);
    }
    /** Does a check if the specified profile is set, and throws otherwise */
    checkProfile(methodName, profile) {
        if (this.strict && !this.supportedProfiles[profile])
            throw new Error(`"${methodName}" cannot be set while "Profile 2" is not enabled.`);
    }
    async executeCommand(message, resend) {
        if (this._currentConnection) {
            this.debugTrace('exec command', message);
            if (!this._currentConnection.connected) {
                return this.switchConnectionsAndExecuteCommand(message);
            }
            try {
                const reply = await this._currentConnection.executeCommand(message);
                return this._ensureReply(reply);
            }
            catch (e) {
                this.debugTrace('errored', e);
                if (this._primaryConnection && this._secondaryConnection && !resend) {
                    return this.switchConnectionsAndExecuteCommand(message);
                }
                else {
                    throw e;
                }
            }
        }
        else {
            throw new Error(`Unable to send message due to no current connection`);
        }
    }
    switchConnections() {
        if (!this._currentConnection)
            throw new Error('Unable to failover connection: No current connection');
        if (!this._primaryConnection)
            throw new Error('Unable to failover connection: No primary connection');
        if (!this._secondaryConnection)
            throw new Error('Unable to failover connection: No secondary connection');
        this.debugTrace('switching connection');
        let otherConnection = this._currentConnection === this._primaryConnection ? this._secondaryConnection : this._primaryConnection;
        const currentConnection = this._currentConnection;
        if (!otherConnection.connected)
            throw new Error(`Unable to failover connection: Other connection is not connected (${otherConnection.host})`);
        // Switch:
        this._currentConnection = otherConnection;
        otherConnection = currentConnection; // former current connection
        otherConnection.handOverQueue(this._currentConnection);
    }
    async switchConnectionsAndExecuteCommand(message) {
        this.switchConnections();
        this.debugTrace('resending msg');
        try {
            return await this.executeCommand(message, true);
        }
        catch (e) {
            if (`${e}` === 'Main server available') {
                // @todo: we may deadlock if primary is down for us, but up for buddy
                return this.switchConnectionsAndExecuteCommand(message);
            }
            this.switchConnections();
            throw e;
        }
    }
    _emitConnectionChange() {
        if (this._callbackOnConnectionChange)
            this._callbackOnConnectionChange(this.getConnectionStatus());
    }
    /** throws if there is an error */
    _ensureReply(reply) {
        if (!reply.mos)
            throw new Error(`Unknown data: <mos> missing from message`);
        if (reply.mos.roAck &&
            reply.mos.roAck.roStatus === 'Buddy server cannot respond because main server is available') {
            throw new Error('Buddy server cannot respond because main server is available');
        }
        if (reply.mos.mosAck && reply.mos.mosAck.status === 'NACK') {
            throw new Error(`Error in response: ${reply.mos.mosAck.statusDescription || 'No statusDescription given'}`);
        }
        return reply;
    }
    /** throws if something's wrong
     */
    _checkProfileValidness(orgStack) {
        if (!this.strict)
            return;
        const fixError = (message) => {
            // Change the stack of the error, so that it points to the original call to the MosDevice:
            const err = new Error(message);
            err.stack = message + orgStack.stack;
            return err;
        };
        /** For MOS-devices: Require a callback to have been set */
        const requireCallback = (profile, callbackName, method) => {
            // @ts-expect-error no index signature
            if (!this[callbackName]) {
                throw fixError(`Error: This MOS-device is configured to support Profile ${profile}, but callback ${method.name} has not been set!`);
            }
        };
        /** Check: Requires that a callback has been set */
        const requireMOSCallback = (profile, callbackName, method) => {
            if (this.supportedProfiles.deviceType !== 'MOS')
                return;
            requireCallback(profile, callbackName, method);
        };
        // const requireNCSCallback = (profile: string, callbackName: string, method: Function) => {
        // 	if (this.supportedProfiles.deviceType !== 'NCS') return
        // 	requireCallback(profile, callbackName, method)
        // }
        /** Require another profile to have been set  */
        const requireProfile = (profile, requiredProfile) => {
            // @ts-expect-error no index signature
            if (!this.supportedProfiles['profile' + requiredProfile]) {
                throw fixError(`Error: This MOS-device is configured to support Profile ${profile}, therefore it must also support Profile ${requiredProfile}!`);
            }
        };
        /* eslint-disable @typescript-eslint/unbound-method */
        if (this.supportedProfiles.profile0) {
            requireCallback('0', '_callbackOnRequestMachineInfo', this.onRequestMachineInfo);
            // _callbackOnConnectionChange not required
        }
        if (this.supportedProfiles.profile1) {
            requireProfile(1, 0);
            requireMOSCallback('1', '_callbackOnRequestMOSOBject', this.onRequestMOSObject);
            requireMOSCallback('1', '_callbackOnRequestAllMOSObjects', this.onRequestAllMOSObjects);
        }
        if (this.supportedProfiles.profile2) {
            requireProfile(2, 0);
            requireProfile(2, 1);
            requireMOSCallback('2', '_callbackOnCreateRunningOrder', this.onCreateRunningOrder);
            requireMOSCallback('2', '_callbackOnReplaceRunningOrder', this.onReplaceRunningOrder);
            requireMOSCallback('2', '_callbackOnDeleteRunningOrder', this.onDeleteRunningOrder);
            requireMOSCallback('2', '_callbackOnRequestRunningOrder', this.onRequestRunningOrder);
            requireMOSCallback('2', '_callbackOnMetadataReplace', this.onMetadataReplace);
            requireMOSCallback('2', '_callbackOnRunningOrderStatus', this.onRunningOrderStatus);
            requireMOSCallback('2', '_callbackOnStoryStatus', this.onStoryStatus);
            requireMOSCallback('2', '_callbackOnItemStatus', this.onItemStatus);
            requireMOSCallback('2', '_callbackOnReadyToAir', this.onReadyToAir);
            requireMOSCallback('2', '_callbackOnROInsertStories', this.onROInsertStories);
            requireMOSCallback('2', '_callbackOnROInsertItems', this.onROInsertItems);
            requireMOSCallback('2', '_callbackOnROReplaceStories', this.onROReplaceStories);
            requireMOSCallback('2', '_callbackOnROReplaceItems', this.onROReplaceItems);
            requireMOSCallback('2', '_callbackOnROMoveStories', this.onROMoveStories);
            requireMOSCallback('2', '_callbackOnROMoveItems', this.onROMoveItems);
            requireMOSCallback('2', '_callbackOnRODeleteStories', this.onRODeleteStories);
            requireMOSCallback('2', '_callbackOnRODeleteItems', this.onRODeleteItems);
            requireMOSCallback('2', '_callbackOnROSwapStories', this.onROSwapStories);
            requireMOSCallback('2', '_callbackOnROSwapItems', this.onROSwapItems);
        }
        if (this.supportedProfiles.profile3) {
            requireProfile(3, 0);
            requireProfile(3, 1);
            requireProfile(3, 2);
            requireMOSCallback('3', '_callbackOnItemReplace', this.onItemReplace);
            requireMOSCallback('3', '_callbackOnObjectCreate', this.onObjectCreate);
            requireMOSCallback('3', '_callbackOnRequestObjectActionNew', this.onRequestObjectActionNew);
            requireMOSCallback('3', '_callbackOnRequestObjectActionUpdate', this.onRequestObjectActionUpdate);
            requireMOSCallback('3', '_callbackOnRequestObjectActionDelete', this.onRequestObjectActionDelete);
            requireMOSCallback('3', '_callbackOnRequestObjectList', this.onRequestObjectList);
            requireMOSCallback('3', '_callbackOnRequestSearchableSchema', this.onRequestSearchableSchema);
        }
        if (this.supportedProfiles.profile4) {
            requireProfile(4, 0);
            requireProfile(4, 1);
            requireProfile(4, 2);
            requireMOSCallback('4', '_callbackOnRequestAllRunningOrders', this.onRequestAllRunningOrders);
            requireMOSCallback('4', '_callbackOnRunningOrderStory', this.onRunningOrderStory);
        }
        if (this.supportedProfiles.profile5) {
            requireProfile(5, 0);
            requireProfile(5, 1);
            requireProfile(5, 2);
            throw fixError('Erorr: Profile 5 is not currently implemented!');
        }
        if (this.supportedProfiles.profile6) {
            requireProfile(6, 0);
            requireProfile(6, 1);
            requireProfile(6, 2);
            throw fixError('Erorr: Profile 6 is not currently implemented!');
        }
        if (this.supportedProfiles.profile7) {
            requireProfile(7, 0);
            requireProfile(7, 1);
            requireProfile(7, 2);
            throw fixError('Erorr: Profile 7 is not currently implemented!');
        }
    }
    debugTrace(...strs) {
        // eslint-disable-next-line no-console
        if (this._debug)
            console.log(...strs);
    }
}
exports.MosDevice = MosDevice;
//# sourceMappingURL=MosDevice.js.map